## 4장 조인 튜닝
## 4.1. NL 조인
### 4.1.1 기본 메커니즘
- 조인이란 두 개 이상 테이블을 하나의 집합으로 만드는 연산
- NL 조인은 프로그래밍에서 사용하는 반복문과 유사한 방식으로 수행
- Outer 테이블 : 반복문 외부에 있는 테이블, 선행 테이블, 외부 테이블
- Inner 테이블 : 반복문 내부에 있는 테이블, 후행 테이블, 내부 테이블
- 양쪽 테이블 모두 인덱스 이용 => NL 조인은 ‘인덱스를 이용한 조인 방식’
- NL 조인하는 과정
  1. 선행 테이블의 인덱스에서 조건을 만족하는 첫 번째 행을 찾는다.
  2. 인덱스에서 읽은 ROWID로 선행 테이블을 액세스한다.
  3. 선행 테이블에서 조건을 만족하는 행의 조인키를 가지고 후행 테이블의 인덱스에 조인키가 존재하는지 찾는다.
  4. 인덱스에서 찾은 조인키의 ROWID를 가지고 후행 테이블을 액세스한다.
  5. ①~④ 작업을 반복 수행한다.

- 선행 테이블의 조건을 만족하는 행을 추출하여 후행 테이블을 읽으면서 조인 수행하기 때문에 선행 테이블의 조건을 만족하는 모든 행의 수만큼 반복 수행
  > 즉, 결과 행의 수가 적은 테이블을 선행 테이블로 선택해야 전체 일량 줄일 수 있음
- NL 조인은 랜덤 액세스이기 때문에 처리 범위가 좁은 것이 유리

### 4.1.2 NL 조인 실행계획 제어
- NL 조인 제어
```
SELECT /*+ ordered use_nl(c)*/
FROM 사원 e, 고객 c
WHERE e.입사일자 >= '19960101'
AND   c.관리사원번호 = e.사원번호
```
- ordered 힌트는 FROM 절에 기술한 순서대로 조인
- use_nl 힌트는 NL 방식으로 조인

```
SELECT /*+ ordered use_nl(B) use_nl(C) use_hash(D) */
FROM A, B, C, D
WHERE ...
```
- ordered가 있으므로 FROM 절 순서대로 조인( A -> B -> C -> D)
- A, B, C 는 NL 방식으로 조인, D와는 해시방식으로 조인

```
SELECT /*+ ordered use_nl(B) use_nl(C) use_hash(D) */
FROM A, B, C, D
WHERE ...
```
- leading 힌트는 순서를 지정하여 조인
- C, A, D 는 NL 방식으로 조인, B와는 해시방식으로 조인
```
SELECT /*+ ordered use_nl(B) use_nl(C) use_hash(D) */
FROM A, B, C, D
WHERE ...
```
- 모두 NL 방식으로 조인, 순서는 옵티마이저가 정함.


### 4.1.3 NL 조인 수행 과정 분석
```
SELECT /*+ ordered use_nl(B) index(e) index(c) */
    e.사원번호, e.사원명, e.입사일자,
    c.고객번호, c.고객명, c.전화번호, c.최종주문고객
FROM 사원 e, 고객 c
WHERE c.관리사원번호 = e.사원번호
AND e.입사일자 >= '19960101'
AND e.부서코드 = 'Z123'
AND c.최종주문금액 >= 20000
```
- 힌트
  - 사원 테이블을 기준으로 고객 테이블과 조인하고 두 테이블 모두
인덱스를 이용해서 액세스한다. 어떤 인덱스를 사용할지는 옵티마이저가 결정.
- 조건절 순서
  1. 사원 테이블의 인덱스는 입사일자로 이루어져 있으며 조건절에 입사일자 범위 조건이 있으므로 사원_X1 인덱스를 Range 스캔한다.
  2. 인덱스에서 읽은 ROWID로 사원 테이블을 액세스하여 조건(부서코드 = ‘Z123’) 에 맞는 레코드를 찾는다.
  3. 사원 테이블에서 찾은 레코드의 조인키(사원번호) 값을 고객 테이블의 인덱스에서 찾는다. ( c.관리사원번호 = e.사원번호 )
  4. 고객 테이블의 인덱스에 읽은 ROWID로 고객 테이블을 액세스하여 조건 (최종주문금액 >= 20000) 에 맞는 레코드를 찾는다.
	> 각 단계를 완료하고 다음 단계로 넘어가지 않고 한 레코드씩 순차적으로 진행

#### 4.1.4 NL 조인 튜닝 포인트
- 위에서는 단일 인덱스인 사원_X1에서 입사일자를 ‘>=’ 조건으로 스캔 했을 때 비교적 비효율 없이 읽고 그만큼 테이블 랜덤 액세스 발생함.
- 하지만, 범위 조건 결과 값이 많고 테이블에서 필터링 되는 비율이 높다면 사원_X1 인덱스에 부서코드 컬럼을 추가하여 테이블을 액세스하는 양을 줄인다.
- 사원 테이블의 결과 건수 = 고객 테이블의 인덱스를 탐색하는 횟수 = 조인 액세스 횟수이므로 	사원 테이블 즉, 선행 테이블의 결과 건수를 줄이는 것이 중요하다.
- 고객_X1 인덱스를 읽고 고객 테이블을 액세스할 때 조건절에 의해 필터링 되는 비율이 높다면 고객_X1 인덱스에 최종주문금액 컬럼을 추가한다.
- 맨 처음 사원_X1 인덱스에서 얻은 결과 건수에 의해 전체 일량이 좌우되므로 결과 행의 수가 적은 테이블을 선행 테이블로 선택해서 전체 일량 줄이도록 한다.

### 4.1.5 NL 조인 특징 요약
- 랜덤 액세스 위주의 조인 방식
  - 레코드 하나를 읽으려고 블록을 통째로 읽는 비효율 발생
- 한 레코드씩 순차적으로 진행
	- 부분범위 처리를 활용하면 빠른 응답 속도를 낼 수 있음.
- 인덱스 구성 전략이 중요
	- 조인 컬럼에 대한 인덱스의 유무와 구성에 따라 조인 효율이 달라짐.
  
### 4.1.6 NL 조인 튜닝 실습
```
SELECT /*+ ordered use_nl(B) index(e) index(c) */
    e.사원번호, e.사원명, e.입사일자,
    c.고객번호, c.고객명, c.전화번호, c.최종주문고객
FROM 사원 e, 고객 c
WHERE c.관리사원번호 = e.사원번호
AND e.입사일자 >= '19960101'
AND e.부서코드 = 'Z123'
AND c.최종주문금액 >= 20000
```   
- 위 쿼리에 대한 SQL 트레이스
(추가예정)

  - 사원_X1 인덱스 스캔하고 사원 테이블을 액세스 한 횟수 : 2780
  - 테이블에서 조건을 필터링 한 결과건수 : 3
  - 불필요한 테이블 액세스가 많고, 필터링 되는 비율이 높음
  - 인덱스에 테이블 필터 조건 컬럼을 추가한다.

- 인덱스 컬럼 추가 후 SQL 트레이스(추가예정)
  - 비효율적인 테이블 액세스는 없어졌지만 액세스하기 전 인덱스 스캔 단계 일량 확인
  - 사원_X1 인덱스로부터 읽은 블록 : 102
  - 한 블록당 평균 500개 레코드가 있다고 가정하면 인덱스에서 3건을 얻기 위해 50,000개의 	레코드를 읽은 셈이다.
  - 입사일자 조건이 범위조건이고 부서코드는 ‘=’ 조건이기 때문에 입사일자 조건에 해당하는 레코드가 아주 많다면 발생하는 비효율이다.
  - [사원_X1 : 부서코드 + 입사일자] 로 인덱스 컬럼 순서를 조정한다.
- 최종 트레이스 결과(추가예정)
  - 인덱스에서 스캔한 블록 4개, 테이블 액세스하고 필터링 되는 레코드 X
  - 사원 테이블을 읽는 부분에서 일량은 많지만, 비효율은 없음
  - 하지만, 고객테이블과 조인하는 부분에서 2780번 조인 시도를 했지만 최종 결과집합은 5건이	  므로 조인 순서 변경 고려(순서 변경도 비효율이 발생하면 소트 머지 조인과 해시 조인 검토)


### 4.1.7 NL 조인 확장 메커니즘
- 오라클은 NL 조인 성능을 높이기 위해 ‘테이블 Prefetch’, ‘배치 I/O’ 기능 도입
- 테이블 Prefetch
  - 인덱스를 이용해 테이블을 액세스하다가 디스크 I/O가 필요하면 곧 읽게 될 	블록까지 미리 읽어서 버퍼캐시에 적재하는 기능
  - 표현 방식(추가예정)

- 배치 I/O : 디스크 I/O Call을 미뤘다가 블록이 일정량 쌓이면 한꺼번에 처리하는 기능
  - 표현 방식(추가예정)

## 4.2 소트 머지 조인

### 4.2.1 SGA ( System Global Area ) vs PGA ( Private Global Area )
#### SGA 
- 서버 프로세스와 백그라운 프로세스가 공통으로 액세스하는 데이터와 제어 구조를 캐싱하는 메모리 공간.
- 여러 프로세스 공유 가능, 동시 액세스 불가 
- 액세스 직렬화를 위한 Lock 매커니즘 존재 = Latch(래치)

#### PGA
-	자신만의 고유 메모리 영역
-	프로세스에 종속적인 고유 데이터를 저장하는 용도
-	공간이 작아 데이터를 저장하지 못하는 경우 Temp 테이블스페이스 사용
-	독립적인 공간으로 같은 양의 데이터일 경우 SGA보다 빠르게 읽을 수 있다. 

#### 소트 머지 조인의 기본 매커니즘
1. 소트단계
   - 양쪽 집합을 조인 컬럼 기준으로 정렬
2. 머지 단계
   - 정렬한 양쪽 집합을 서로 머지

```
SELECT /*+ ordered use_merge(c) */
    e.사원번호, e.사원명, e.입사일자,
    c.고객번호, c.고객명, c.전화번호, c.최종주문금액
FROM 사원 e, 고객 c
WHERE c.관리사원번호 = e.사원번호
AND e.입사일자 >= '19960101'
AND e.부서코드 = 'Z123'
AND c.최종주문금액 >= 20000
```
>( 힌트 – use_merge 소트 머지 조인 유도 힌트 / ordered 사원테이블 기준 )

### 4.2.2 SQL 수행과정
1. 조건에 해당하는 사원데이터를 사원번호 순으로 정렬해서 PGA 영역에 저장
2. 조건에 해당하는 고객 데이터를 조인컬럼인 관리사원번호 순으로 정렬해 PGA 영역에 저장
3. PGA에 저장된 사원 데이터를 스캔하면서 PGA에 저장된 고객 데이터와 조인 -> NL 조인과 같음
-	고객 데이터를 매번 Full scan 하지 않는다. 
-	고객 데이터가 정렬되어 있어 원하는 지점을 쉽게 찾을 수 있다. 
-	데이터 자체가 인덱스 역할을 한다. = 인덱스가 없어도 사용 가능한 조인 방식
-	대량 데이터 조인시 NL 조인보다 유리하다. 

### 4.2.3 소트 머지 조인이 빠른 이유
-	Sort Area의 미리 정렬된 자료구조 사용
-	PGA 공간이 프로세스만을 위한 독립적인 메모리 공간이므로 래치 획득 과정이 없다. 

#### 대량 데이터 조인에 유리한 이유
-	NL 조인은 모든 인덱스와 테이블이 블록에 래치 획득 및 캐시버퍼에 체인 스캔 과정을 거친다. 버퍼캐시에 없는 블록은 건건이 디스크에서 읽는다. 
### 4.2.4 소트 머지 조인의 주용도
-	조인 조건식이 등치 (=) 조건이 아닌 대량 데이터 조인
   - 등치 조건일 경우 해시 조인이 더 빠르다. 
-	조인 조건식이 아예 없는 조인 
### 4.2.5 소트 머지 조인 제어하기
-	힌트를 사용해서 제어 ( 280p 참고 )

### 4.2.6 소트 머지 조인 특징
-	조인을 위한 실시간 인덱스 생성과 같음
-	소트 부하 감수시, 건건이 버퍼캐시를 경유하는 NL 조인보다 빠름
-	인덱스 유무에 영향을 받지 않음
-	양쪽 집합을 개별적으로 읽고 조인 수행 
   - 조인 컬럼에 인덱스가 없는 경우 두 테이블에서 조인 대상 집합을 줄일 수 있을 때 유리함
-	스캔 위주의 액세스 방식 사용
-	조인 대상 레코드를 찾을 때 인덱스를 사용할 수 도 있고 그때는 랜덤 액세스 이용

## 4.3 해시 조인
- 조인 과정에서 인덱스를 사용하지 않음
  - 대량 데이터 조인할 때 NL 조인보다 훨씬 빠르고, 일정한 성능을 보임.
- 소트 머지 조인과 달리 항상 양쪽 테이블을 정렬하는 부담을 가지고 있지 않음.

### 4.3.1 기본 매커니즘
- Build 단계
  - 작은 쪽 테이블(Build Input)을 읽어 해시 테이블(해시 맵)을 생성.
- Probe 단계
  - 큰 쪽 테이블(Probe Input)을 읽어 해시 테이블을 탐색하면서 조인.
- use_hash
  - 옵티마이저가 해시 조인을 수행하도록 유도하는 힌트
- 해시 테이블은 PGA 영역에 할당된 Hash Area에 저장.
- 해시 테이블이 너무 커 PGA에 담을 수 없으면, Temp 테이블 스페이스에 저장

#### Ex> 해시 조인 SQL 수행과정 예제(그림 추가 예정)

#### [ Ex – SQL 구문 해시 조인 처리 구성도 ](그림 추가 예정)
  
#### [Ex - Probe 단계 조인 과정을 나타낸 PL/SQL 구문(p.284 참조)]
```
begin
	for outer in (select 고객번호, …from 고객 where 최종주문금액 >= 20000)
	loop	-- outer 루프
		for inner in (select 사원번호, … from PGA에 생성한_사원_해시맵 where 사원번호=outer.관리사원번호)
		loop	-- inner 루프
			dbms_output.put_line( … );
		end loop;
	end loop;
end;
```
- Probe 단계는 NL 조인과 다르지 않음.

### 4.3.2	해시 조인이 빠른 이유
#### 해시 조인 vs. NL 조인
- 해시 테이블을 PGA 영역에 할당: NL 조인과 같이 Outer 테이블 레코드마다 Inner 쪽 테이블 레코드를 읽기 위해 래치 획득 및 캐시 체인 스캔 과정의 반복이 없음.
- 해시 조인도 Build Input과 Probe Input 각 테이블을 읽을 때는 DB 버퍼캐시를 경유하고, 이때 인덱스를 이용하기도 함 – 이 과정에서 발생하는 버퍼캐시 탐색 비용과 랜덤 액세스 부하는 피할 수 없음

#### 해시 조인 vs. 소트 머지 조인
- 둘 다 조인 오퍼레이션을 PGA에서 처리하지만 대량의 데이터를 조인할 때 둘 간의 사전 준비작업 방식의 차이로 인해 일반적으로 해시 조인이 더 빠름
- 해시 조인 vs. 소트 머지 조인 사전 준비작업 비교

||해시 조인|소트 머지 조인|
|--|--|--|
|PGA 할당 대상|한쪽: 해시 테이블, Build Input 대상|양쪽: 대상 집합을 모두 정렬한 후|
|Temp 테이블스페이스 사용|둘 중 작은 집합을 해시 맵 Build Input으로 선택하므로 Temp 영역 사용 가능성 낮음	|두 집합 중 어느 하나가 중대형 이상이면, Temp 테이블스페이스 사용(디스크에 쓰는 작업)|

- NL 조인 처럼 조인 과정에서 발생하는 랜덤 액세스 부하가 없고, 소트 머지 조인처럼 양쪽 집합을 미리 정렬하는 부하도 없음.

#### 해시 테이블에 담기는 정보: 조인 키 값 + SQL에 사용한 모든 컬럼 데이터

### 4.3.3	대용량 Build Input 처리
▶ 조인 대상 테이블이 모두 대용량 테이블이어서 인메모리 해시 조인이 불가능한 상황
▶ 분할 * 정복(Divide & Conquer) 방식 적용

1)	파티션 단계
: 파티션 짝(pair) 생성 단계 – 독립적으로 처리할 수 있는 여러 개의 작은 서브 집합으로 분할
      
①	조인하는 양쪽 집합의 조인 컬럼에 해시 함수를 적용
②	반환된 해시 값에 따라 동적으로 파티셔닝(그림 4-13 참조)
☞ 양쪽 집합(T1, T2)을 읽어 디스크 Temp 공간에 저장(T1’, T2’)
※ 파티셔닝(Partitioning): 테이블 또는 인덱스 데이터를 특정 컬럼(파티션 키) 값에 따라 별도 세그먼트에 나눠서 저장하는 것. - [ 6.3.1 참조 ]

2)	조인 단계
: 각 파티션 짝(pair)에 대해 하나씩 조인을 수행
각각에 대한 Build Input과 Probe Input은 독립적으로 결정됨. 즉, 파티션하기 전 어느 쪽이 작은 테이블이었는지에 상관없이 각 파티션 짝(pair)별로 작은 쪽을 Build Input으로 선택하고 해시 테이블을 생성
반대편 파티션 로우를 하나씩 읽으면서 해시 테이블을 탐색, 모든 파티션 짝에 대한 처리를 마칠 때까지 이 과정을 반복.

▶ In-Memory Hash Join(한 테이블의 카디널리티가 적은 경우)와 대용량 Build Input 비교
In-Memory Hash Join 처리 단계	대용량 Build Input 처리 단계
①	작은 쪽 테이블(Build Input)을 읽어 해시 테이블(해시 맵)을 생성
②	큰 쪽 테이블(Probe Input)을 읽어 해시 테이블을 탐색하면서 조인	①	파티션 짝(pair) 생성 및 Temp 공간에 저장
②	Temp 공간에 생성된 각 파티션 로우 짝 중 작은 쪽을 Build Input으로 선택하고 해시 테이블 생성
③	반대편 파티션 짝(Probe Input) 로우를 하나씩 읽으면서 해시 테이블 탐색하면서 조인 

4.	해시 조인 실행계획 제어
 
☞ 위쪽(HASH JOIN 바로 아래) 사원 데이터(Build Input)로 해시 테이블을 생성한 후, 아래쪽 고객 테이블(Probe Input)에서 읽은 조인 키값으로 해시 테이블을 탐색하면서 조인

▶ Build Input 대상 지정
1) 옵티마이저: 일반적으로 조인 대상 테이블 중 카디널리티(조건절에 대한 카디널리티)가 작은 테이블을 선택
2) 사용자 지정 - [p.291 쿼리 참조]
▷ leading이나 ordered 힌트를 사용
Ex) /*+ leading(e) use_hash(c) */ or /*+ ordered use_hash(c) */
▷ swap_join_inputs: Build Input 대상을 명시적으로 선택
Ex) /*+ leading(e) use_hash(c) swap_join_inputs(c) */: 고객 테이블 Build Input
   /*+ leading(e) use_hash(c) swap_join_inputs(e) */: 사원 테이블 Build Input

▣ 세 개 이상 테이블 해시 조인
▷ 해시 조인에서 leading 힌트 첫 번째 파라미터로 지정한 테이블은 무조건 Build Input으로 선택 됨.
Ex) /*+ leading(T1, T2, T3) use_hash(T2) use_hash(T3) */ - [p.293 쿼리 참조, 실행 계획 참조]
▷ swap_join_inputs: Build Input 대상을 명시적으로 선택.
Ex) /*+ leading(T1, T2, T3) swap_join_inputs(T2) */ - [p.294 쿼리 참조, 실행 계획 참조]

☞ swap_join_inputs 옵션 적용에 따른 실행 계획 비교
SQL> select * from T1, T2, T3 where T1.key = T2.key and T2.key = T3.key
/*+ leading(T1, T2, T3) use_hash(T2) use_hash(T3) */	/*+ leading(T1, T2, T3) swap_join_inputs(T2) */
 


  
▷ no_swap_join_inputs: Probe Input 대상을 지정(오라클 10.1.0.3 버전부터 제공).
Ex) /*+ leading(T1, T2, T3) no_sqap_join_inputs(T3) */ - [p.295 첫 번째 쿼리 참조]
※ no_swap_join_inputs 없을 시 인라인 뷰(from 절 뒤에 오는 서브쿼리)를 생성하고 그 인라인 뷰 Alias로 제어 - [p.295 두 번째 쿼리 참조]



5. 조인 메소드 선택 기준
조인 메소드	선택 기준
NL 조인	소량 데이터(랜덤 액세스가 많아 만족할 만한 성능을 낼 수 없는) 조인할 때
해시 조인	대량 데이터 조인할 때 – 조인 조건식에 등치(=) 조건 사용
소트 머지 조인	대량 데이터 조인인데 해시 조인으로 처리할 수 없을 때 

▶ 수행빈도가 매우 높은 쿼리 처리 선택 기준
① (최적화된) NL 조인과 해시 조인 성능이 같으면, NL 조인
② 해시 조인이 약간 더 빨라도 NL 조인
③ NL 조인보다 해시 조인이 매우 빠른 경우, 해시 조인

▶ 조인 메소드를 선택할 때 NL 조인을 가장 먼저 고려해야 하는 이유
: NL 조인에 사용하는 인덱스는 영구적으로 유지하면서 다양한 쿼리를 위해 공유 및 재사용하는 자료구조인 반면, 해시 테이블은 단 하나의 쿼리를 위해 생성하고 조인이 끝나면 소멸하는 자료구조
☞ 수행시간이 짧으면서 수행빈도가 매우 높은 쿼리를 해시 조인으로 처리하면 CPU와 메모리 사용률이 크게 증가

▶ 해시 조인을 사용하는 SQL문 조건
① 수행 빈도가 낮고
② 쿼리 수행 시간이 오래 걸리는
③ 대량 데이터 조인할 때
☞ 배치 프로그램, DW, OLAP성 쿼리의 특성을 가짐.







